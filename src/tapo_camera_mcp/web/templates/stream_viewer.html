{% extends "base.html" %}

{% block title %}{{ camera_name }} Stream - Tapo Camera MCP{% endblock %}

{% block extra_css %}
<style>
    .stream-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 24px;
    }
    
    .stream-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
    }
    
    .stream-header h1 {
        font-size: 24px;
        font-weight: 700;
        color: var(--text-color);
        margin: 0;
    }
    
    .stream-status {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 16px;
        border-radius: 20px;
        font-weight: 500;
        font-size: 14px;
    }
    
    .stream-status.live {
        background: var(--success-light);
        color: #166534;
    }
    
    .stream-status.loading {
        background: var(--warning-bg);
        color: #92400e;
    }
    
    .stream-status.error {
        background: var(--error-bg);
        color: #dc2626;
    }
    
    .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        animation: pulse 2s infinite;
    }
    
    .status-dot.live { background: var(--success-green); }
    .status-dot.loading { background: var(--warning-yellow); }
    .status-dot.error { background: var(--error-red); }
    
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }
    
    .stream-card {
        background: #000;
        border-radius: 16px;
        overflow: hidden;
        margin-bottom: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    }
    
    /* Fullscreen styles */
    .stream-card:fullscreen,
    .stream-card:-webkit-full-screen,
    .stream-card:-moz-full-screen,
    .stream-card:-ms-fullscreen {
        width: 100vw;
        height: 100vh;
        border-radius: 0;
    }
    
    .stream-card:fullscreen .stream-video,
    .stream-card:-webkit-full-screen .stream-video {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
    
    .stream-video-container {
        position: relative;
        width: 100%;
        aspect-ratio: 16/9;
        background: #111;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .stream-video {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
    
    .stream-overlay {
        position: absolute;
        top: 16px;
        left: 16px;
        display: flex;
        gap: 8px;
    }
    
    .stream-badge {
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
    }
    
    .stream-badge.live-badge {
        background: #dc2626;
    }
    
    .stream-loading {
        color: var(--gray-400);
        text-align: center;
    }
    
    .stream-loading .spinner {
        width: 60px;
        height: 60px;
        border: 4px solid #333;
        border-top-color: #f97316;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 16px;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    
    .stream-controls {
        background: #1a1a1a;
        padding: 16px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 12px;
    }
    
    .control-group {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
    }
    
    .ctrl-btn {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 18px;
        border-radius: 8px;
        font-weight: 500;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.15s ease;
        border: none;
        text-decoration: none;
    }
    
    .ctrl-btn-play {
        background: var(--success-green);
        color: white;
    }
    
    .ctrl-btn-play:hover {
        background: #16a34a;
    }
    
    .ctrl-btn-stop {
        background: var(--error-red);
        color: white;
    }
    
    .ctrl-btn-stop:hover {
        background: #dc2626;
    }
    
    .ctrl-btn-secondary {
        background: var(--text-color);
        color: white;
    }
    
    .ctrl-btn-secondary:hover {
        background: var(--gray-600);
    }
    
    .stream-info-bar {
        background: var(--card-bg);
        border-radius: 12px;
        padding: 16px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 16px;
    }
    
    .info-item {
        display: flex;
        align-items: center;
        gap: 8px;
        color: var(--muted-text);
        font-size: 14px;
    }
    
    .info-item strong {
        color: var(--text-color);
    }
    
    .copy-toast {
        position: fixed;
        bottom: 24px;
        left: 50%;
        transform: translateX(-50%) translateY(100px);
        background: var(--success-green);
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        font-weight: 500;
        opacity: 0;
        transition: all 0.3s ease;
        z-index: 1000;
    }
    
    .copy-toast.show {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
    }
    
    .error-banner {
        background: #fef2f2;
        border: 1px solid #fecaca;
        color: #dc2626;
        padding: 16px;
        border-radius: 12px;
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 12px;
    }
    
    /* PTZ Controls */
    .ptz-overlay {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.85);
        border-radius: 12px;
        padding: 16px;
        display: none;
        z-index: 10;
    }
    
    .ptz-overlay.active {
        display: block;
    }
    
    .ptz-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 1px solid var(--text-color);
    }
    
    .ptz-title {
        color: var(--border-color);
        font-weight: 600;
        font-size: 13px;
    }
    
    .ptz-close {
        background: none;
        border: none;
        color: var(--gray-400);
        font-size: 20px;
        cursor: pointer;
        padding: 0;
        line-height: 1;
    }
    
    .ptz-close:hover {
        color: white;
    }
    
    .ptz-body {
        display: flex;
        gap: 20px;
        align-items: center;
    }
    
    .ptz-dpad {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
    }
    
    .ptz-row {
        display: flex;
        gap: 4px;
    }
    
    .ptz-btn {
        width: 40px;
        height: 40px;
        border: none;
        border-radius: 8px;
        background: var(--primary-blue);
        color: white;
        font-size: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.15s ease;
    }
    
    .ptz-btn:hover {
        background: var(--primary-blue-dark);
        transform: scale(1.05);
    }
    
    .ptz-btn:active {
        background: #1d4ed8;
        transform: scale(0.95);
    }
    
    .ptz-btn.ptz-home {
        background: var(--muted-text);
        font-size: 12px;
    }
    
    .ptz-btn.ptz-home:hover {
        background: var(--gray-600);
    }
    
    .ptz-zoom {
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .zoom-label {
        font-size: 11px;
        color: #fbbf24;
        font-weight: 600;
        text-align: center;
        margin-bottom: 2px;
    }

    .ptz-zoom .ptz-btn {
        width: 48px;
        font-size: 14px;
    }
    
    .ctrl-btn-ptz {
        background: #8b5cf6;
        color: white;
    }
    
    .ctrl-btn-ptz:hover {
        background: #7c3aed;
    }
    
    .ctrl-btn-ptz.active {
        background: #6d28d9;
        box-shadow: 0 0 0 2px #a78bfa;
    }

    /* Preset Styles */
    .ptz-presets {
        margin-top: 16px;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        padding-top: 12px;
    }

    .preset-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
    }

    .preset-header span {
        color: #fbbf24;
        font-weight: 600;
        font-size: 14px;
    }

    .preset-btn {
        background: var(--success-dark);
        color: white;
        border: none;
        border-radius: 6px;
        padding: 4px 8px;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.15s ease;
    }

    .preset-btn:hover {
        background: #047857;
        transform: scale(1.05);
    }

    .preset-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
        max-height: 120px;
        overflow-y: auto;
    }

    .preset-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        padding: 6px 8px;
        font-size: 12px;
        color: white;
    }

    .preset-item:hover {
        background: rgba(255, 255, 255, 0.15);
    }

    .preset-name {
        flex: 1;
        font-weight: 500;
        cursor: pointer;
    }

    .preset-name:hover {
        color: #fbbf24;
    }

    .preset-actions {
        display: flex;
        gap: 4px;
    }

    .preset-action-btn {
        background: none;
        border: none;
        color: var(--gray-400);
        cursor: pointer;
        padding: 2px;
        border-radius: 3px;
        font-size: 10px;
        transition: all 0.15s ease;
    }

    .preset-action-btn:hover {
        color: white;
        background: rgba(255, 255, 255, 0.1);
    }

    .preset-action-btn.delete:hover {
        color: var(--error-red);
    }

    /* Preset Dialog */
    .preset-dialog {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
    }

    .preset-dialog-content {
        background: var(--text-color);
        border-radius: 12px;
        padding: 20px;
        max-width: 400px;
        width: 90%;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
    }

    .preset-dialog-content h3 {
        margin: 0 0 16px 0;
        color: #fbbf24;
        font-size: 18px;
    }

    .preset-dialog-content input {
        width: 100%;
        padding: 8px 12px;
        margin-bottom: 8px;
        border: 1px solid var(--text-color);
        border-radius: 6px;
        background: var(--gray-900);
        color: white;
        font-size: 14px;
    }

    .preset-dialog-content input:focus {
        outline: none;
        border-color: #fbbf24;
    }

    .preset-dialog-buttons {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        margin-top: 16px;
    }

    .preset-dialog-buttons button {
        padding: 8px 16px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.15s ease;
    }

    .preset-dialog-buttons button:first-child {
        background: var(--muted-text);
        color: white;
    }

    .preset-dialog-buttons button:first-child:hover {
        background: var(--gray-600);
    }

    .preset-save-btn {
        background: var(--success-dark);
        color: white;
    }

    .preset-save-btn:hover {
        background: #047857;
    }

    /* Microscope Controls */
    .microscope-controls {
        margin-top: 16px;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        padding-top: 12px;
    }

    .microscope-header {
        margin-bottom: 8px;
    }

    .microscope-header span {
        color: #fbbf24;
        font-weight: 600;
        font-size: 14px;
    }

    .microscope-body {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .microscope-setting {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: var(--border-color);
    }

    .microscope-setting label {
        min-width: 100px;
    }

    .microscope-setting input[type="number"] {
        width: 60px;
        padding: 2px 4px;
        border: 1px solid var(--text-color);
        border-radius: 4px;
        background: var(--gray-900);
        color: white;
        font-size: 12px;
    }

    .microscope-setting input[type="range"] {
        flex: 1;
        max-width: 80px;
    }

    .microscope-setting button {
        background: var(--success-dark);
        color: white;
        border: none;
        border-radius: 4px;
        padding: 2px 8px;
        font-size: 11px;
        cursor: pointer;
    }

    .microscope-setting button:hover {
        background: #047857;
    }

    .microscope-tools {
        display: flex;
        gap: 6px;
        margin-top: 4px;
    }

    .microscope-tools button {
        flex: 1;
        background: #7c3aed;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 4px 8px;
        font-size: 11px;
        cursor: pointer;
    }

    .microscope-tools button:hover {
        background: #6d28d9;
    }
</style>
{% endblock %}

{% block content %}
<div class="stream-container">
    <div class="stream-header">
        <h1>üé• {{ camera_name }}</h1>
        <div class="stream-status loading" id="stream-status">
            <span class="status-dot loading"></span>
            <span id="status-text">Connecting...</span>
        </div>
    </div>
    
    <div id="error-banner" class="error-banner" style="display: none;">
        <span>WARNING</span>
        <span id="error-text"></span>
    </div>
    
    <div class="stream-card">
        <div class="stream-video-container" id="video-container">
            <div class="stream-loading" id="stream-loading">
                <div class="spinner"></div>
                <p>Starting live stream...</p>
            </div>
            <img id="stream-video" class="stream-video" style="display: none;" alt="Live stream">
            <div class="stream-overlay">
                <span class="stream-badge live-badge" id="live-badge" style="display: none;">‚óè LIVE</span>
                <span class="stream-badge" id="camera-badge">{{ camera_name }}</span>
            </div>
            
            <!-- PTZ Overlay -->
            <div class="ptz-overlay" id="ptz-overlay">
                <div class="ptz-header">
                    <span class="ptz-title" id="ptz-title">üéÆ PTZ Controls</span>
                    <button class="ptz-close" onclick="togglePTZ()">&times;</button>
                </div>
                <div class="ptz-body">
                    <div class="ptz-dpad">
                        <button class="ptz-btn" onclick="ptzMove(event, 0, 1.0, 0)">‚ñ≤</button>
                        <div class="ptz-row">
                            <button class="ptz-btn" onclick="ptzMove(event, -1.0, 0, 0)">‚óÄ</button>
                            <button class="ptz-btn ptz-home" onclick="ptzHome()">‚åÇ</button>
                            <button class="ptz-btn" onclick="ptzMove(event, 1.0, 0, 0)">‚ñ∂</button>
                        </div>
                        <button class="ptz-btn" onclick="ptzMove(event, 0, -1.0, 0)">‚ñº</button>
                    </div>
                    <div class="ptz-zoom">
                        <div class="zoom-label">Digital Zoom</div>
                        <button class="ptz-btn" onclick="digitalZoomIn()">üîç+</button>
                        <button class="ptz-btn" onclick="digitalZoomOut()">üîç‚àí</button>
                    </div>

                    <!-- Custom Presets -->
                    <div class="ptz-presets">
                        <div class="preset-header">
                            <span>‚≠ê Favorite Positions</span>
                            <button class="preset-btn" onclick="showSavePresetDialog()">üíæ Save</button>
                        </div>
                        <div class="preset-list" id="preset-list">
                            <!-- Presets will be loaded here -->
                        </div>
                    </div>

                    <!-- Microscope Controls (only shown for microscope cameras) -->
                    <div class="microscope-controls" id="microscope-controls" style="display: none;">
                        <div class="microscope-header">
                            <span>üî¨ Microscope Controls</span>
                        </div>
                        <div class="microscope-body">
                            <div class="microscope-setting">
                                <label>Magnification:</label>
                                <input type="number" id="magnification" min="1" max="1000" step="1" value="50">
                                <button onclick="setMagnification()">Set</button>
                            </div>
                            <div class="microscope-setting">
                                <label>LED Brightness:</label>
                                <input type="range" id="led-brightness" min="0" max="100" value="75">
                                <span id="brightness-value">75%</span>
                            </div>
                            <div class="microscope-tools">
                                <button onclick="autoFocus()">Auto Focus</button>
                                <button onclick="calibrateMicroscope()">Calibrate</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Save Preset Dialog -->
                <div class="preset-dialog" id="preset-dialog" style="display: none;">
                    <div class="preset-dialog-content">
                        <h3>üíæ Save Current Position</h3>
                        <input type="text" id="preset-name" placeholder="Preset name (e.g., Door, Window, Ceiling, Blind Spot)" maxlength="20">
                        <input type="text" id="preset-description" placeholder="Optional description" maxlength="50">
                        <div class="preset-dialog-buttons">
                            <button onclick="hideSavePresetDialog()">Cancel</button>
                            <button onclick="saveCurrentPreset()" class="preset-save-btn">Save Position</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="stream-controls">
            <div class="control-group">
                <button onclick="startStream()" class="ctrl-btn ctrl-btn-play" id="btn-play">
                    ‚ñ∂ Start Stream
                </button>
                <button onclick="stopStream()" class="ctrl-btn ctrl-btn-stop" id="btn-stop" style="display: none;">
                    ‚èπ Stop
                </button>
                <button onclick="refreshSnapshot()" class="ctrl-btn ctrl-btn-secondary">
                    üì∏ Snapshot
                </button>
                <button onclick="togglePTZ()" class="ctrl-btn ctrl-btn-ptz" id="btn-ptz">
                    üéÆ PTZ
                </button>
            </div>
            <div class="control-group">
                <button id="btn-fullscreen" class="ctrl-btn ctrl-btn-secondary">
                    ‚õ∂ Fullscreen
                </button>
                <button onclick="popoutStream()" class="ctrl-btn ctrl-btn-secondary">
                    ‚Üó Pop Out
                </button>
                <a href="/cameras" class="ctrl-btn ctrl-btn-secondary">
                    ‚Üê Back
                </a>
            </div>
        </div>
    </div>
    
    <div class="stream-info-bar">
        <div class="info-item">
            <span>üì°</span>
            <strong>Camera:</strong>
            <span>{{ camera_id }}</span>
        </div>
        <div class="info-item">
            <span>üîó</span>
            <strong>RTSP:</strong>
            <span id="rtsp-display">Loading...</span>
            <button onclick="copyStreamUrl()" class="ctrl-btn ctrl-btn-secondary" style="padding: 6px 12px; font-size: 12px;">
                üìã Copy
            </button>
        </div>
    </div>
</div>

<div class="copy-toast" id="copy-toast">‚úÖ Copied to clipboard!</div>

<script>
const cameraId = "{{ camera_id }}";
const cameraType = "{{ camera_type }}";  // Add camera type from template
let streamUrl = null;
let isStreaming = false;
let isRingCamera = cameraType === 'ring';

async function loadStreamInfo() {
    try {
        const response = await fetch(`/api/cameras/${encodeURIComponent(cameraId)}/stream`);
        const data = await response.json();
        
        if (data.stream_url) {
            streamUrl = data.stream_url;
            // Show truncated URL
            const displayUrl = streamUrl.length > 50 ? streamUrl.substring(0, 50) + '...' : streamUrl;
            document.getElementById('rtsp-display').textContent = displayUrl;
        }
    } catch (err) {
        console.error('Failed to load stream info:', err);
    }
}

function startStream() {
    // Reset digital zoom when starting new stream
    resetDigitalZoom();

    const video = document.getElementById('stream-video');
    const loading = document.getElementById('stream-loading');
    const liveBadge = document.getElementById('live-badge');
    const btnPlay = document.getElementById('btn-play');
    const btnStop = document.getElementById('btn-stop');
    const status = document.getElementById('stream-status');
    const statusText = document.getElementById('status-text');
    const statusDot = status.querySelector('.status-dot');

    // Show loading
    loading.style.display = 'block';
    video.style.display = 'none';

    // Handle Ring cameras with WebRTC
    if (isRingCamera) {
        startRingWebRTCStream();
        return;
    }

    // Regular MJPEG stream for other cameras
    video.src = `/api/cameras/${encodeURIComponent(cameraId)}/mjpeg?t=${Date.now()}`;

    video.onload = () => {
        loading.style.display = 'none';
        video.style.display = 'block';
        // Load microscope controls if this is a microscope camera
        loadMicroscopeControls();
        liveBadge.style.display = 'inline';
        btnPlay.style.display = 'none';
        btnStop.style.display = 'inline-flex';

        status.className = 'stream-status live';
        statusDot.className = 'status-dot live';
        statusText.textContent = 'Live';
        isStreaming = true;
    };

    video.onerror = () => {
        showError('Failed to start stream. Make sure the camera is online.');
        loading.style.display = 'none';
        status.className = 'stream-status error';
        statusDot.className = 'status-dot error';
        statusText.textContent = 'Error';
    };

    // For MJPEG, the img will start loading immediately
    setTimeout(() => {
        if (video.complete && video.naturalWidth > 0) {
            video.onload();
        }
    }, 500);
}

function stopStream() {
    const video = document.getElementById('stream-video');
    const liveBadge = document.getElementById('live-badge');
    const btnPlay = document.getElementById('btn-play');
    const btnStop = document.getElementById('btn-stop');
    const status = document.getElementById('stream-status');
    const statusText = document.getElementById('status-text');
    const statusDot = status.querySelector('.status-dot');

    // Handle Ring WebRTC streams
    if (isRingCamera) {
        stopRingWebRTCStream();
        video.srcObject = null;
    } else {
        video.src = '';
    }

    video.style.display = 'none';
    liveBadge.style.display = 'none';
    btnPlay.style.display = 'inline-flex';
    btnStop.style.display = 'none';

    status.className = 'stream-status loading';
    statusDot.className = 'status-dot loading';
    statusText.textContent = 'Stopped';
    isStreaming = false;

    // Show snapshot instead (for non-Ring cameras)
    if (!isRingCamera) {
        refreshSnapshot();
    }
}

function refreshSnapshot() {
    const video = document.getElementById('stream-video');
    const loading = document.getElementById('stream-loading');

    if (isStreaming) return;

    // For Ring cameras, show last recording instead of snapshot
    if (isRingCamera) {
        loading.innerHTML = '<div class="spinner"></div><p>Loading last recording...</p>';
        loading.style.display = 'block';
        video.style.display = 'none';

        // Get last recording from Ring API
        fetch(`/api/ring/recording/last/${encodeURIComponent(cameraId)}`)
            .then(response => response.json())
            .then(data => {
                if (data.video_url) {
                    video.src = data.video_url;
                    video.style.display = 'block';
                    loading.style.display = 'none';
                } else {
                    loading.innerHTML = '<p style="color: var(--gray-400);">üé• No recent recordings<br><small>Click "Start Stream" for live view</small></p>';
                }
            })
            .catch(err => {
                console.error('Failed to load Ring recording:', err);
                loading.innerHTML = '<p style="color: var(--gray-400);">üé• Recording unavailable<br><small>Click "Start Stream" for live view</small></p>';
            });
    } else {
        // Regular snapshot for other cameras
        loading.innerHTML = '<div class="spinner"></div><p>Loading snapshot...</p>';
        loading.style.display = 'block';
        video.style.display = 'none';

        const img = new Image();
        img.src = `/api/cameras/${encodeURIComponent(cameraId)}/snapshot?t=${Date.now()}`;
        img.onload = () => {
            video.src = img.src;
            video.style.display = 'block';
            loading.style.display = 'none';
        };
        img.onerror = () => {
            loading.innerHTML = '<p style="color: var(--gray-400);">üì∑ Snapshot unavailable</p>';
        };
    }
}

function popoutStream() {
    const streamUrl = `/api/cameras/${encodeURIComponent(cameraId)}/mjpeg`;
    const win = window.open('', 'stream_' + cameraId, 'width=1280,height=720,menubar=no,toolbar=no,location=no,status=no');
    win.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
            <title>${cameraId} - Live Stream</title>
            <style>
                * { margin: 0; padding: 0; }
                body { background: #000; display: flex; align-items: center; justify-content: center; height: 100vh; }
                img { max-width: 100%; max-height: 100%; object-fit: contain; }
            </style>
        </head>
        <body ondblclick="document.documentElement.requestFullscreen()">
            <img src="${streamUrl}" alt="Live Stream">
        </body>
        </html>
    `);
}

function toggleStreamFullscreen() {
    // Try the stream card (parent container) for better fullscreen experience
    const streamCard = document.querySelector('.stream-card');
    const video = document.getElementById('stream-video');
    const target = streamCard || video;
    
    if (!target) {
        console.error('No fullscreen target found');
        return;
    }
    
    // Check if already in fullscreen
    const fsElement = document.fullscreenElement || 
                      document.webkitFullscreenElement || 
                      document.mozFullScreenElement ||
                      document.msFullscreenElement;
    
    if (fsElement) {
        // Exit fullscreen
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    } else {
        // Enter fullscreen
        if (target.requestFullscreen) {
            target.requestFullscreen();
        } else if (target.webkitRequestFullscreen) {
            target.webkitRequestFullscreen();
        } else if (target.mozRequestFullScreen) {
            target.mozRequestFullScreen();
        } else if (target.msRequestFullscreen) {
            target.msRequestFullscreen();
        }
    }
}

function copyStreamUrl() {
    if (!streamUrl) {
        showToast('No stream URL available');
        return;
    }
    
    navigator.clipboard.writeText(streamUrl).then(() => {
        showToast('‚úÖ RTSP URL copied!');
    }).catch(() => {
        // Fallback
        const ta = document.createElement('textarea');
        ta.value = streamUrl;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        showToast('‚úÖ RTSP URL copied!');
    });
}

function showToast(msg) {
    const toast = document.getElementById('copy-toast');
    toast.textContent = msg;
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), 2000);
}

function showError(msg) {
    const banner = document.getElementById('error-banner');
    document.getElementById('error-text').textContent = msg;
    banner.style.display = 'flex';
}

// PTZ Functions
let ptzActive = false;

function updatePTZTitle() {
    const titleElement = document.getElementById('ptz-title');
    if (!titleElement) return;

    if (digitalZoomLevel > 1.0) {
        titleElement.textContent = 'üéÆ Digital PTZ (Zoomed)';
        titleElement.style.color = '#fbbf24'; // Yellow to indicate digital mode
    } else {
        titleElement.textContent = 'üéÆ PTZ Controls';
        titleElement.style.color = 'var(--border-color)'; // Normal color
    }
}

function togglePTZ() {
    const overlay = document.getElementById('ptz-overlay');
    const btn = document.getElementById('btn-ptz');
    ptzActive = !ptzActive;

    if (ptzActive) {
        overlay.classList.add('active');
        btn.classList.add('active');
        // Load presets when opening PTZ controls
        loadPresets();
        // Update title based on current zoom state
        updatePTZTitle();
    } else {
        overlay.classList.remove('active');
        btn.classList.remove('active');
        // Reset digital zoom when closing PTZ controls
        resetDigitalZoom();
    }
}

// PTZ movement state
let ptzMovementInterval = null;
let currentPTZMovement = { pan: 0, tilt: 0, zoom: 0 };

async function ptzMove(event, pan, tilt, zoom) {
    try {
        // Determine movement strategy based on camera capabilities and zoom state
        const usePhysicalPTZ = zoom !== 0; // Zoom control always uses physical (if available)
        const useDigitalPanTilt = digitalZoomLevel > 1.0 && (pan !== 0 || tilt !== 0);

        if (useDigitalPanTilt) {
            // Use digital pan/tilt within zoomed view
            digitalPanTilt(pan, tilt);
        } else if (usePhysicalPTZ || pan !== 0 || tilt !== 0) {
            // Send single relative PTZ movement command
            const response = await fetch('/api/ptz/move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    camera_name: cameraId,
                    pan: pan,
                    tilt: tilt,
                    zoom: zoom
                })
            });

            if (!response.ok) {
                console.error('PTZ command failed:', response.status);
            } else {
                console.log(`PTZ moved: pan=${pan}, tilt=${tilt}, zoom=${zoom}`);
            }
        }

        // Determine movement type for feedback
        let movementType = "PTZ";
        if (useDigitalPanTilt) {
            movementType = "Digital Pan/Tilt";
        } else if (zoom !== 0) {
            movementType = "Zoom";
        }

        console.log(`${movementType} Move started: pan=${pan.toFixed(3)}, tilt=${tilt.toFixed(3)}, zoom=${zoom.toFixed(3)}`);

        // Immediate visual feedback (don't wait for camera response)
        const statusText = document.getElementById('status-text');
        if (statusText) {
            statusText.textContent = `${movementType} Moving...`;
            statusText.style.color = 'var(--success-green)'; // Green to show immediate response
        }

        // Add button press feedback
        if (event && event.target) {
            event.target.style.background = 'var(--success-green)'; // Green flash
            setTimeout(() => {
                event.target.style.background = ''; // Reset after 100ms
            }, 100);
        }

    } catch (err) {
        console.error('PTZ move start error:', err);
        showError(`PTZ Error: ${err.message}`);
    }
}

async function ptzStop() {
    try {
        // Clear the movement interval
        if (ptzMovementInterval) {
            clearInterval(ptzMovementInterval);
            ptzMovementInterval = null;
        }

        // Reset movement direction
        currentPTZMovement = { pan: 0, tilt: 0, zoom: 0 };

        // Send stop command to camera
        const response = await fetch(`/api/ptz/stop/${encodeURIComponent(cameraId)}`, { method: 'POST' });
        if (!response.ok) {
            console.error('PTZ stop failed');
        }

        console.log('PTZ movement stopped');

        // Reset status display
        const statusText = document.getElementById('status-text');
        if (statusText) {
            statusText.textContent = 'Live';
        }

    } catch (err) {
        console.error('PTZ stop error:', err);
    }
}

// Preset Functions
let currentPresets = [];

async function loadPresets() {
    try {
        const response = await fetch(`/api/ptz/presets/custom/${encodeURIComponent(cameraId)}`);
        const data = await response.json();
        if (data.success) {
            currentPresets = data.presets;
            renderPresets();
        }
    } catch (err) {
        console.error('Failed to load presets:', err);
    }
}

function renderPresets() {
    const presetList = document.getElementById('preset-list');
    presetList.innerHTML = '';

    if (currentPresets.length === 0) {
        presetList.innerHTML = '<div style="color: var(--gray-400); font-size: 12px; text-align: center; padding: 8px;">No saved positions yet</div>';
        return;
    }

    currentPresets.forEach(preset => {
        const presetItem = document.createElement('div');
        presetItem.className = 'preset-item';

        presetItem.innerHTML = `
            <span class="preset-name" onclick="gotoPreset('${preset.name}')" title="${preset.description || ''}">
                ${preset.name}
            </span>
            <div class="preset-actions">
                <button class="preset-action-btn delete" onclick="deletePreset('${preset.name}')" title="Delete preset">üóë</button>
            </div>
        `;

        presetList.appendChild(presetItem);
    });
}

async function gotoPreset(presetName) {
    try {
        const response = await fetch('/api/ptz/presets/custom/goto', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                camera_name: cameraId,
                preset_name: presetName
            })
        });
        const data = await response.json();
        if (data.success) {
            showToast(`Moving to "${presetName}"`);
        } else {
            showError(`Failed to go to preset: ${data.detail || 'Unknown error'}`);
        }
    } catch (err) {
        console.error('Preset goto error:', err);
        showError('Failed to move to preset position');
    }
}

async function deletePreset(presetName) {
    if (!confirm(`Delete preset "${presetName}"?`)) return;

    try {
        const response = await fetch('/api/ptz/presets/custom/delete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                camera_name: cameraId,
                preset_name: presetName
            })
        });
        const data = await response.json();
        if (data.success) {
            showToast(`Deleted preset "${presetName}"`);
            await loadPresets();
        } else {
            showError(`Failed to delete preset: ${data.detail || 'Unknown error'}`);
        }
    } catch (err) {
        console.error('Preset delete error:', err);
        showError('Failed to delete preset');
    }
}

function showSavePresetDialog() {
    document.getElementById('preset-dialog').style.display = 'flex';
    document.getElementById('preset-name').focus();
}

function hideSavePresetDialog() {
    document.getElementById('preset-dialog').style.display = 'none';
    document.getElementById('preset-name').value = '';
    document.getElementById('preset-description').value = '';
}

async function saveCurrentPreset() {
    const name = document.getElementById('preset-name').value.trim();
    const description = document.getElementById('preset-description').value.trim();

    if (!name) {
        showError('Please enter a preset name');
        return;
    }

    // Check if name already exists
    if (currentPresets.some(p => p.name === name)) {
        if (!confirm(`Preset "${name}" already exists. Overwrite it?`)) return;
    }

    try {
        const response = await fetch('/api/ptz/presets/custom/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                camera_name: cameraId,
                preset_name: name,
                description: description
            })
        });
        const data = await response.json();
        if (data.success) {
            showToast(`Saved preset "${name}"`);
            hideSavePresetDialog();
            await loadPresets();
        } else {
            showError(`Failed to save preset: ${data.detail || 'Unknown error'}`);
        }
    } catch (err) {
        console.error('Preset save error:', err);
        showError('Failed to save preset position');
    }
}

// Close dialog when clicking outside
document.getElementById('preset-dialog').addEventListener('click', function(e) {
    if (e.target === this) {
        hideSavePresetDialog();
    }
});

// Close dialog on Escape key
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && document.getElementById('preset-dialog').style.display === 'flex') {
        hideSavePresetDialog();
    }
});

// Microscope Functions
async function loadMicroscopeControls() {
    try {
        // Check if current camera is a microscope
        const response = await fetch(`/api/cameras/status`);
        const data = await response.json();

        const camera = data.cameras.find(c => c.name === cameraId);
        const isMicroscope = camera && camera.type === 'microscope';

        const microscopeControls = document.getElementById('microscope-controls');
        if (microscopeControls) {
            microscopeControls.style.display = isMicroscope ? 'block' : 'none';
        }

        if (isMicroscope) {
            // Load microscope settings
            const infoResponse = await fetch(`/api/microscope/info/${cameraId}`);
            const infoData = await infoResponse.json();
            if (infoData.success) {
                document.getElementById('magnification').value = infoData.info.current_magnification || 50;
                document.getElementById('led-brightness').value = infoData.info.current_led_brightness || 75;
                updateBrightnessValue();
            }
        }
    } catch (err) {
        console.error('Failed to load microscope controls:', err);
    }
}

function updateBrightnessValue() {
    const brightness = document.getElementById('led-brightness').value;
    document.getElementById('brightness-value').textContent = brightness + '%';
}

async function setMagnification() {
    const magnification = parseFloat(document.getElementById('magnification').value);
    try {
        const response = await fetch('/api/microscope/magnification', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                camera_name: cameraId,
                magnification: magnification
            })
        });
        const data = await response.json();
        if (data.success) {
            showToast(`Magnification set to ${magnification}x`);
        } else {
            showError('Failed to set magnification');
        }
    } catch (err) {
        console.error('Magnification error:', err);
        showError('Failed to set magnification');
    }
}

async function setLEDBrightness() {
    const brightness = parseInt(document.getElementById('led-brightness').value);
    try {
        const response = await fetch('/api/microscope/led', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                camera_name: cameraId,
                brightness: brightness
            })
        });
        const data = await response.json();
        if (data.success) {
            showToast(`LED brightness set to ${brightness}%`);
        } else {
            showError('Failed to set LED brightness');
        }
    } catch (err) {
        console.error('LED brightness error:', err);
        showError('Failed to set LED brightness');
    }
}

async function autoFocus() {
    try {
        const response = await fetch(`/api/microscope/autofocus/${cameraId}`, {
            method: 'POST'
        });
        const data = await response.json();
        if (data.success) {
            showToast('Auto-focus completed');
        } else {
            showToast('Auto-focus not supported');
        }
    } catch (err) {
        console.error('Auto-focus error:', err);
        showError('Auto-focus failed');
    }
}

async function calibrateMicroscope() {
    const instructions = 'To calibrate:\n1. Place a ruler under the microscope\n2. Measure a known distance in pixels\n3. Enter the actual distance in mm\n\nExample: If 100 pixels = 1mm, enter:\nPixels: 100, mm: 1.0';

    const pixelDistance = prompt('Enter known distance in pixels:');
    if (!pixelDistance) return;

    const actualDistance = prompt('Enter actual distance in mm:');
    if (!actualDistance) return;

    try {
        const response = await fetch('/api/microscope/calibrate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                camera_name: cameraId,
                known_distance_pixels: parseInt(pixelDistance),
                actual_distance_mm: parseFloat(actualDistance)
            })
        });
        const data = await response.json();
        if (data.success) {
            showToast(`Calibrated: ${data.calibration_factor} mm/pixel`);
        } else {
            showError('Calibration failed');
        }
    } catch (err) {
        console.error('Calibration error:', err);
        showError('Calibration failed');
    }
}

// Initialize LED brightness slider
document.addEventListener('DOMContentLoaded', function() {
    const brightnessSlider = document.getElementById('led-brightness');
    if (brightnessSlider) {
        brightnessSlider.addEventListener('input', updateBrightnessValue);
        brightnessSlider.addEventListener('change', setLEDBrightness);
    }
});

// Digital Zoom & Pan/Tilt State
let digitalZoomLevel = 1.0;
let digitalPanOffset = 0;  // -50 to 50 (percentage of zoomed area)
let digitalTiltOffset = 0; // -50 to 50 (percentage of zoomed area)

const MAX_DIGITAL_ZOOM = 3.0;
const MIN_DIGITAL_ZOOM = 1.0;
const ZOOM_STEP = 0.25;
const DIGITAL_PAN_STEP = 5;  // percentage points

// WebRTC for Ring cameras
let peerConnection = null;
let ringKeepAliveInterval = null;

function digitalZoomIn() {
    if (digitalZoomLevel < MAX_DIGITAL_ZOOM) {
        digitalZoomLevel = Math.min(MAX_DIGITAL_ZOOM, digitalZoomLevel + ZOOM_STEP);
        applyDigitalZoom();
        updatePTZTitle(); // Update title when zoom changes
        showToast(`Digital Zoom: ${digitalZoomLevel.toFixed(1)}x`);
    }
}

function digitalZoomOut() {
    if (digitalZoomLevel > MIN_DIGITAL_ZOOM) {
        digitalZoomLevel = Math.max(MIN_DIGITAL_ZOOM, digitalZoomLevel - ZOOM_STEP);
        // Reset pan/tilt offsets when zooming out to 1x
        if (digitalZoomLevel <= 1.0) {
            digitalPanOffset = 0;
            digitalTiltOffset = 0;
        }
        applyDigitalZoom();
        updatePTZTitle(); // Update title when zoom changes
        showToast(`Digital Zoom: ${digitalZoomLevel.toFixed(1)}x`);
    }
}

// Digital pan/tilt within zoomed view
function digitalPanTilt(pan, tilt) {
    if (digitalZoomLevel <= 1.0) {
        // No digital pan/tilt at 1x zoom
        return;
    }

    // Adjust pan/tilt offsets within zoomed area
    const maxOffset = 50 * (digitalZoomLevel - 1); // More zoom = more pan/tilt range

    digitalPanOffset = Math.max(-maxOffset, Math.min(maxOffset, digitalPanOffset + (pan * DIGITAL_PAN_STEP)));
    digitalTiltOffset = Math.max(-maxOffset, Math.min(maxOffset, digitalTiltOffset + (tilt * DIGITAL_PAN_STEP)));

    applyDigitalZoom();
}

function applyDigitalZoom() {
    const videoElement = document.getElementById('stream-video');
    if (videoElement) {
        // Apply zoom scale
        let transform = `scale(${digitalZoomLevel})`;

        // Apply pan/tilt offsets within zoomed area
        if (digitalZoomLevel > 1.0 && (digitalPanOffset !== 0 || digitalTiltOffset !== 0)) {
            transform += ` translate(${digitalPanOffset * 0.5}%, ${digitalTiltOffset * 0.5}%)`;
        }

        videoElement.style.transform = transform;
        videoElement.style.transformOrigin = 'center center';
        videoElement.style.transition = 'transform 0.1s ease';

        // Adjust container to handle zoom overflow
        const container = videoElement.parentElement;
        if (container) {
            if (digitalZoomLevel > 1.0) {
                container.style.overflow = 'hidden';
            } else {
                container.style.overflow = 'visible';
            }
        }
    }
}

function resetDigitalZoom() {
    digitalZoomLevel = 1.0;
    digitalPanOffset = 0;
    digitalTiltOffset = 0;
    applyDigitalZoom();
}

async function startRingWebRTCStream() {
    try {
        console.log('Starting Ring WebRTC stream...');

        // Create RTCPeerConnection
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        peerConnection = new RTCPeerConnection(configuration);

        // Handle ICE candidates
        peerConnection.onicecandidate = async (event) => {
            if (event.candidate) {
                try {
                    await fetch('/api/ring/webrtc/candidate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            candidate: event.candidate.candidate,
                            device_id: cameraId
                        })
                    });
                } catch (err) {
                    console.error('Failed to send ICE candidate:', err);
                }
            }
        };

        // Handle remote stream
        peerConnection.ontrack = (event) => {
            const video = document.getElementById('stream-video');
            const loading = document.getElementById('stream-loading');
            const liveBadge = document.getElementById('live-badge');
            const btnPlay = document.getElementById('btn-play');
            const btnStop = document.getElementById('btn-stop');
            const status = document.getElementById('stream-status');
            const statusText = document.getElementById('status-text');
            const statusDot = status.querySelector('.status-dot');

            if (event.streams && event.streams[0]) {
                video.srcObject = event.streams[0];
                loading.style.display = 'none';
                video.style.display = 'block';
                liveBadge.style.display = 'inline';
                btnPlay.style.display = 'none';
                btnStop.style.display = 'inline-flex';

                status.className = 'stream-status live';
                statusDot.className = 'status-dot live';
                statusText.textContent = 'Live (WebRTC)';
                isStreaming = true;

                console.log('Ring WebRTC stream established');
            }
        };

        // Create offer
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        // Send offer to Ring
        const response = await fetch('/api/ring/webrtc/offer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                sdp_offer: offer.sdp,
                device_id: cameraId
            })
        });

        if (!response.ok) {
            throw new Error(`WebRTC offer failed: ${response.status}`);
        }

        const data = await response.json();

        // Set remote description
        await peerConnection.setRemoteDescription({
            type: 'answer',
            sdp: data.sdp_answer
        });

        // Start keep-alive
        ringKeepAliveInterval = setInterval(async () => {
            try {
                await fetch(`/api/ring/webrtc/keepalive/${cameraId}`, {
                    method: 'POST'
                });
            } catch (err) {
                console.warn('Ring keep-alive failed:', err);
            }
        }, 30000); // Keep alive every 30 seconds

    } catch (err) {
        console.error('Failed to start Ring WebRTC stream:', err);
        showError('Failed to start Ring live stream. Make sure the doorbell is online and you have the correct permissions.');
        stopRingWebRTCStream();
    }
}

function stopRingWebRTCStream() {
    // Clear keep-alive interval
    if (ringKeepAliveInterval) {
        clearInterval(ringKeepAliveInterval);
        ringKeepAliveInterval = null;
    }

    // Close peer connection
    if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
    }

    // Close WebRTC stream
    try {
        fetch(`/api/ring/webrtc/close/${cameraId}`, {
            method: 'POST'
        }).catch(err => console.warn('Failed to close WebRTC stream:', err));
    } catch (err) {
        console.warn('Error closing Ring WebRTC stream:', err);
    }
}

async function ptzHome() {
    try {
        const response = await fetch('/api/ptz/home', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ camera_name: cameraId })
        });
        const data = await response.json();
        if (!data.success) {
            console.error('PTZ home failed:', data.error);
        }
    } catch (err) {
        console.error('PTZ home error:', err);
    }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    loadStreamInfo();
    // Auto-start stream
    setTimeout(startStream, 500);
    
    // Fullscreen button handler
    const fsBtn = document.getElementById('btn-fullscreen');
    if (fsBtn) {
        fsBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            toggleStreamFullscreen();
        });
    }
    
    // Double-click on video to toggle fullscreen
    const video = document.getElementById('stream-video');
    if (video) {
        video.addEventListener('dblclick', toggleStreamFullscreen);
    }
    
    // Also on the container
    const container = document.getElementById('video-container');
    if (container) {
        container.addEventListener('dblclick', toggleStreamFullscreen);
    }
});
</script>
{% endblock %}

